# Introduction

Secure Hash Algorithm 2, 256-bit (SHA-256) is a cryptographic hash
function belonging to the SHA-2 family of hash functions. First
published by the United States National Security Agency (NSA) in 2001,
SHA-256 is now formally standardized in the Federal Information
Processing Standards Publication 180-4 (FIPS 180-4). SHA-256 is an
iterative, one-way cryptographic hash function that can process a
message to produce a 256-bit condensed representation called a digest.
Any change to the message will, with a high probability, result in a
different digest, enabling SHA-256 to determine the message's integrity.

# Notation and Conventions

The following symbols and terminology related to bit strings and
integers will be used.

-   A number with the prefix $\text{0b}$ means such number is in base 2
    (binary). Similarly, a number with the prefix $\text{0x}$ means such
    number is in base 16 (hexadecimal).

-   A hex digit is the representation of a 4-bit number and is an
    element of the set\
    $\{\text{0x0}, \text{0x1},…, \text{0x9}, \text{0xa},…, \text{0xf}\}$.
    For example, the hex digit $\text{0x}7$ represents the 4-bit number
    $\text{0b}0111$, and the hex digit $\text{0xa}$ represents the 4-bit
    number $\text{0b}1010$.

-   An integer between $0$ and $2^{32} -1$ inclusive may be represented
    as a 32-bit data type. The least significant four bits of the
    integer are represented by the right-most hex digit of the integer
    representation. For example, the decimal integer $291$ is
    represented by the hexadecimal integer $\text{0x}00000123$.

## Mathematical Symbols

::: center
  ---------- -------------------------------------
   $\land$        Bitwise conjunction (AND).
    $\lor$    Bitwise inclusive disjunction (OR).
   $\oplus$   Bitwise exclusive disjuntion (XOR).
    $\neg$         Bitwise complement (NOT).
    $\gg$            Bitwise right-shift.
  ---------- -------------------------------------
:::

# Constants, Operations, and Functions

SHA-256 uses the same sequence of 64 constant 32-bit integers denoted as
$K_0, K_1, ..., K_{63}$. The 64 integers are listed below:

::: center
   428a2f98   71374491   b5c0fbcf   e9b5dba5
  ---------- ---------- ---------- ----------
   3956c25b   59f111f1   923f82a4   ab1c5ed5
   d807aa98   12835b01   243185be   550c7dc3
   72be5d74   80deb1fe   9bdc06a7   c19bf174
   e49b69c1   efbe4786   0fc19dc6   240ca1cc
   2de92c6f   4a7484aa   5cb0a9dc   76f988da
   983e5152   a831c66d   b00327c8   bf597fc7
   c6e00bf3   d5a79147   06ca6351   14292967
   27b70a85   2e1b2138   4d2c6dfc   53380d13
   650a7354   766a0abb   81c2c92e   92722c85
   a2bfe8a1   a81a664b   c24b8b70   c76c51a3
   d192e819   d6990624   f40e3585   106aa070
   19a4c116   1e376c08   2748774c   34b0bcb5
   391c0cb3   4ed8aa4a   5b9cca4f   682e6ff3
   748f82ee   78a5636f   84c87814   8cc70208
   90befffa   a4506ceb   bef9a3f7   c67178f2
:::

## Operations and Functions

The following operation defines a circular shift (rotation) of $x$ by
$n$ positions to the right, where $x$ is a 32-bit integer:

$$\displaystyle \text{ROTR}(x, n) = (x \gg n) \lor (x \ll 32 - n)$$

Furthermore, the following logical functions are used:
$$\displaystyle \text{Ch}(x, y, z) = (x \land y) \oplus (\neg x \land z)$$
$$\displaystyle \text{Maj}(x, y, z) = (x \land y) \oplus (x \land z) \oplus (y \land z)$$
$$\displaystyle \Sigma_0(x) = \text{ROTR}(x, 2) \oplus \text{ROTR}(x, 13) \oplus \text{ROTR}(x, 22)$$
$$\displaystyle \Sigma_1(x) = \text{ROTR}(x, 6) \oplus \text{ROTR}(x, 11) \oplus \text{ROTR}(x, 25)$$
$$\displaystyle \sigma_0(x) = \text{ROTR}(x, 7) \oplus \text{ROTR}(x, 18) \oplus (x \gg 3)$$
$$\displaystyle \sigma_1(x) = \text{ROTR}(x, 17) \oplus \text{ROTR}(x, 19) \oplus (x \gg 10)$$

# Preprocessing

Preprocessing consists of three steps: padding the message, parsing the
message into blocks, and setting the initial hash value.

## Padding

Let $M$ denote the raw message (in bits) and let the length of message
$M$ be denoted as $l$ (in bits, $0 \leq l < 2^{64}$).

1.  Append a single \"1\" bit to the end of $M$.

2.  Append $k$ \"0\" bits, where $k$ is the smallest non-negative
    solution to the equation: $$\displaystyle
        l + 1 + k \equiv 448 \bmod 512$$

3.  As $l$ can be represented by a 64-bit integer, the final 64-bits are
    reserved for representing the value of $l$.

For example, the message \"abc\" has a length of $l=24$ bits, so the
message is padded with a single \"1\" bit, then 423 \"0\" bits, and then
the 64-bit message length $l$ to become the 512 padded message:
$$\displaystyle
\text{0b}\underbrace{01100001}_{\textbf{"a"}} \underbrace{01100010}_{\textbf{"b"}} \underbrace{01100011}_{\textbf{"c"}}  \overbrace{1}^{\text{single "1" bit}} \;\; \overbrace{000...00}^{\text{423 "0" bits}} \overbrace{\text00...\underbrace{011000}_{l = 24}}^{\text{64 bits}}$$

The length of the padded message should now be a multiple of 512 bits.

## Parsing

The message and its padding must be parse into $N$ 512-bit blocks
$M^{(1)}, M^{(2)}, ..., M^{(N)}$. Furthermore, each 512-bit block can be
divided into sixteen 32-bit integers:

::: center
  --------------- --------------- ------- ----------------- --------------- --------------- ------- ------------------
    $M^{(1)}_0$     $M^{(1)}_1$    $...$    $M^{(1)}_{6}$     $M^{(1)}_7$     $M^{(1)}_8$    $...$    $M^{(1)}_{15}$
    $M^{(2)}_0$     $M^{(2)}_1$    $...$    $M^{(2)}_{6}$     $M^{(2)}_7$     $M^{(2)}_8$    $...$    $M^{(2)}_{15}$
    $M^{(3)}_0$     $M^{(3)}_1$    $...$    $M^{(3)}_{6}$     $M^{(3)}_7$     $M^{(3)}_8$    $...$    $M^{(3)}_{15}$
   $M^{(...)}_0$   $M^{(...)}_1$   $...$   $M^{(...)}_{6}$   $M^{(...)}_7$   $M^{(...)}_8$   $...$   $M^{(...)}_{15}$
    $M^{(N)}_0$     $M^{(N)}_1$    $...$    $M^{(N)}_{6}$     $M^{(N)}_7$     $M^{(N)}_8$    $...$    $M^{(N)}_{15}$
  --------------- --------------- ------- ----------------- --------------- --------------- ------- ------------------
:::

## Initializing Hash Values

For SHA-256, the initial hash value $H^{(0)}$ is made up of the
following 32-bit integers:
$$\displaystyle H^{(0)}_0 = \text{0x6a09e667}$$
$$\displaystyle H^{(0)}_1 = \text{0xbb67ae85}$$
$$\displaystyle H^{(0)}_2 = \text{0x3c6ef372}$$
$$\displaystyle H^{(0)}_3 = \text{0xa54ff53a}$$
$$\displaystyle H^{(0)}_4 = \text{0x510e527f}$$
$$\displaystyle H^{(0)}_5 = \text{0x9b05688c}$$
$$\displaystyle H^{(0)}_6 = \text{0x1f83d9ab}$$
$$\displaystyle H^{(0)}_7 = \text{0x5be0cd19}$$

These were obtained by taking the first 32 bits of the fractional parts
of the first 8 prime numbers' square roots.

# Hashing

When hashing, SHA-256 uses a message schedule of sixty-four 32-bit
integers, eight working 32-bit variables, and a hash value of eight
32-bit integers. Each message block $M^{(1)}, M^{(2)}, ..., M^{(N)}$ is
processed in order, using the following steps:

-   For $i = 1$ to $N$:

    1.  Prepare the message schedule $W_j$:
        $$\displaystyle  W_j = \begin{cases} 
                      M^{(i)}_j & 0 \leq j \leq 15 \\
                      \sigma_1(W_{j-2}) + W_{j-7} + \sigma_0(W_{j-15}) + W_{j-16} & 16 \leq j \leq 63
                        \end{cases}$$

    2.  Initialize eight working variables with the $i-1$ hash value:
        $$\displaystyle a = H^{(i-1)}_0, \; b = H^{(i-1)}_1, \; c = H^{(i-1)}_2, \; d = H^{(i-1)}_3,$$$$\displaystyle e = H^{(i-1)}_4, \; f = H^{(i-1)}_5, \; g = H^{(i-1)}_6, \; h = H^{(i-1)}_7$$

    3.  For $j = 0$ to $63$:
        $$\displaystyle T_1 = \big[h + \Sigma_1(e) + \text{Ch}(e,f,g) + K_j + W_j\big] \mod 2^{32}$$
        $$\displaystyle T_2 = \big[\Sigma_0(a) + \text{Maj}(a,b,c)\big]  \mod 2^{32}$$
        $$\displaystyle h = g$$ $$\displaystyle g = f$$
        $$\displaystyle f = e$$
        $$\displaystyle e = \big[d + T_1\big]  \mod 2^{32}$$
        $$\displaystyle d = c$$ $$\displaystyle c = b$$
        $$\displaystyle b = a$$
        $$\displaystyle a = \big[T_1 + T_2 \big] \mod 2^{32}$$

    4.  Compute the $i$th intermediate hash value $H^{(i)}$:
        $$\displaystyle H^{(i)}_0 = \big[a + H^{(i-1)}_0 \big]  \mod 2^{32}$$
        $$\displaystyle H^{(i)}_1 = \big[b + H^{(i-1)}_1 \big]  \mod 2^{32}$$
        $$\displaystyle H^{(i)}_2 = \big[c + H^{(i-1)}_2 \big]  \mod 2^{32}$$
        $$\displaystyle H^{(i)}_3 = \big[d + H^{(i-1)}_3 \big]  \mod 2^{32}$$
        $$\displaystyle H^{(i)}_4 = \big[e + H^{(i-1)}_4 \big]  \mod 2^{32}$$
        $$\displaystyle H^{(i)}_5 = \big[f + H^{(i-1)}_5 \big]  \mod 2^{32}$$
        $$\displaystyle H^{(i)}_6 = \big[g + H^{(i-1)}_6 \big]  \mod 2^{32}$$
        $$\displaystyle H^{(i)}_7 = \big[h + H^{(i-1)}_7 \big]  \mod 2^{32}$$

After repeating steps one through four above a total of $N$ times (that
is, after processing block $M^{(N)}$), the resulting 256-bit message
digest is formed by concatenating the eight hash values:

$$\displaystyle \text{digest} = \textbf{CONCAT}\big(H^{(N)}_0, H^{(N)}_1, H^{(N)}_2, H^{(N)}_3, H^{(N)}_4, H^{(N)}_5, H^{(N)}_6, H^{(N)}_7)$$
The number of possible digests SHA-256 can generate is
$2^{256} \approx 1.15792 \times 10^{77}.$ A brute-force attack against
SHA-256 hashes would take a modern GPU ($1.15 \times 10^8$ hashes per
second) $2.3 \times 10^{51}$ times the age of the universe to complete.
